{"version":3,"file":"841-724800.js","mappings":"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","sources":["webpack://TopWritePlugins.highlight/./src/utils/prsim.ts","webpack://TopWritePlugins.highlight/./src/highlight-plugin.tsx","webpack://TopWritePlugins.highlight/./src/components/activate.tsx"],"sourcesContent":["import Prism from 'prismjs';\r\nimport 'prismjs/components/prism-markdown';\r\n\r\nPrism.languages.insertBefore('markdown', 'blockquote', {\r\n    'code-block': {\r\n        pattern: /^```.*$/m,\r\n        alias: 'code'\r\n    },\r\n    leafDirective: {\r\n        pattern: /^\\:\\:(w+?)/,\r\n        alias: 'code'\r\n    }\r\n});\r\n\r\nPrism.languages.insertBefore('markdown', 'url-reference', {\r\n    'image': {\r\n        pattern: /!\\[[^\\]]*\\](?:\\([^)]+\\))/,\r\n        alias: 'url'\r\n    },\r\n});\r\n\r\nPrism.languages.insertBefore('markdown', 'prolog', {\r\n    'align': {\r\n        pattern: /:?-+?:?/,\r\n        alias: 'keyword'\r\n    }\r\n});\r\n\r\nexport default Prism;\r\n","import Prism from './utils/prsim';\r\nimport { CodeElement, Element, Node, Path, Range, Text } from 'slate';\r\nimport { createPlatePlugin, css, styled } from 'topwrite';\r\nimport { Token } from 'prismjs';\r\n\r\nconst languages = {\r\n    'application/json': 'javascript',\r\n    'text/css': 'css',\r\n    'text/markdown': 'markdown'\r\n};\r\n\r\nconst getLength = (token: Token | string): number => {\r\n    if (typeof token === 'string') {\r\n        return token.length;\r\n    } else {\r\n        let content = token.content;\r\n        if (typeof content === 'string') {\r\n            return content.length;\r\n        } else {\r\n            if (!Array.isArray(content)) {\r\n                content = [content];\r\n            }\r\n            return content.reduce((l, t) => l + getLength(t), 0);\r\n        }\r\n    }\r\n};\r\n\r\nexport const HighlightPlugin = createPlatePlugin({\r\n    renderLeaf() {\r\n        return ({ leaf, children }) => {\r\n            return <Container\r\n                $comment={leaf.comment || leaf.prolog || leaf.doctype || leaf.cdata}\r\n                $punctuation={leaf.punctuation}\r\n                $namespace={leaf.namespace}\r\n                $property={leaf.property || leaf.tag || leaf.boolean || leaf.number || leaf.constant || leaf.symbol || leaf.delete}\r\n                $selector={leaf.selector || leaf['attr-name'] || leaf.string || leaf.char || leaf.builtin || leaf.inserted}\r\n                $operator={leaf.operator || leaf.entity || leaf.url}\r\n                $keyword={leaf.keyword || leaf.atrule || leaf['attr-value']}\r\n                $function={leaf.function || leaf['class-name']}\r\n                $variable={leaf.variable || leaf.regex || leaf.important}\r\n                $important={leaf.important || leaf.bold}\r\n                $italic={leaf.italic}\r\n                $entity={leaf.entity}\r\n            >\r\n                {children}\r\n            </Container>;\r\n        };\r\n    },\r\n    decorate(editor) {\r\n        if (editor.isDocument) {\r\n            return ([node, path]) => {\r\n                const ranges: Range[] = [];\r\n                if (Element.isElementType<CodeElement>(node, 'code')) {\r\n                    const lang = node.lang || 'clike';\r\n                    const grammar = Prism.languages[lang] || Prism.languages['clike'];\r\n\r\n                    let texts = Array.from(Node.texts(node));\r\n                    const nodeText = texts.map(([t]) => t.text).join('\\n');\r\n                    const tokens = Prism.tokenize(nodeText, grammar);\r\n\r\n                    let textStart = 0;\r\n                    let textEnd = 0;\r\n\r\n                    texts.forEach(([text, p]) => {\r\n                        textEnd = textStart + text.text.length;\r\n\r\n                        let offset = 0;\r\n\r\n                        function processToken(token: Token | string, marks: string[] = []) {\r\n                            if (typeof token === 'string') {\r\n                                if (marks.length > 0) {\r\n                                    const range = createRange({\r\n                                        path: path.concat(p),\r\n                                        textStart,\r\n                                        textEnd,\r\n                                        start: offset,\r\n                                        end: offset + token.length,\r\n                                        marks: marks\r\n                                    });\r\n                                    if (range) {\r\n                                        ranges.push(range);\r\n                                    }\r\n                                }\r\n                                offset += token.length;\r\n                            } else {\r\n                                marks.push(token.type);\r\n                                if (token.alias) {\r\n                                    marks.push(...Array.isArray(token.alias) ? token.alias : [token.alias]);\r\n                                }\r\n                                let content = token.content;\r\n                                if (typeof content === 'string') {\r\n                                    const range = createRange({\r\n                                        path: path.concat(p),\r\n                                        textStart,\r\n                                        textEnd,\r\n                                        start: offset,\r\n                                        end: offset + content.length,\r\n                                        marks: marks\r\n                                    });\r\n                                    if (range) {\r\n                                        ranges.push(range);\r\n                                    }\r\n\r\n                                    offset += content.length;\r\n                                } else {\r\n                                    if (!Array.isArray(content)) {\r\n                                        content = [content];\r\n                                    }\r\n                                    // When using token.content instead of token.matchedStr, token can be deep\r\n                                    for (let i = 0; i < content.length; i += 1) {\r\n                                        processToken(content[i], marks);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        tokens.forEach(token => processToken(token));\r\n                        textStart = textEnd + 1; // account for added `\\n`\r\n                    });\r\n                }\r\n                return ranges;\r\n            };\r\n        } else {\r\n            const language = languages[editor.mime as keyof typeof languages];\r\n            if (!language) {\r\n                return;\r\n            }\r\n            return ([node, path]) => {\r\n                if (!Text.isText(node)) {\r\n                    return [];\r\n                }\r\n\r\n                const ranges: Range[] = [];\r\n                const tokens = Prism.tokenize(node.text, Prism.languages[language]);\r\n                let start = 0;\r\n\r\n                for (const token of tokens) {\r\n                    const length = getLength(token);\r\n                    const end = start + length;\r\n\r\n                    if (typeof token !== 'string') {\r\n                        const range = {\r\n                            [token.type]: true,\r\n                            anchor: { path, offset: start },\r\n                            focus: { path, offset: end },\r\n                        };\r\n\r\n                        if (token.alias) {\r\n                            const alias = Array.isArray(token.alias) ? token.alias : [token.alias];\r\n                            for (const name of alias) {\r\n                                range[name] = true;\r\n                            }\r\n                        }\r\n\r\n                        ranges.push(range);\r\n                    }\r\n\r\n                    start = end;\r\n                }\r\n\r\n                return ranges;\r\n            };\r\n        }\r\n    }\r\n});\r\n\r\nfunction createRange({\r\n    path,\r\n    textStart,\r\n    textEnd,\r\n    start,\r\n    end,\r\n    marks\r\n}: {\r\n    path: Path,\r\n    textStart: number,\r\n    textEnd: number,\r\n    start: number,\r\n    end: number,\r\n    marks: string[]\r\n}): Range | null {\r\n    if (start >= textEnd || end <= textStart) {\r\n        // Ignore, the token is not in the text\r\n        return null;\r\n    }\r\n\r\n    // Shrink to this text boundaries\r\n    start = Math.max(start, textStart);\r\n    end = Math.min(end, textEnd);\r\n\r\n    // Now shift offsets to be relative to this text\r\n    start -= textStart;\r\n    end -= textStart;\r\n\r\n    const range: Range = {\r\n        anchor: {\r\n            path,\r\n            offset: start,\r\n        },\r\n        focus: {\r\n            path,\r\n            offset: end\r\n        }\r\n    };\r\n\r\n    for (const mark of marks) {\r\n        // @ts-ignore\r\n        range[mark] = true;\r\n    }\r\n\r\n    return range;\r\n}\r\n\r\n\r\ninterface Style {\r\n    $comment?: boolean;\r\n    $punctuation?: boolean;\r\n    $namespace?: boolean;\r\n    $property?: boolean;\r\n    $selector?: boolean;\r\n    $operator?: boolean;\r\n    $keyword?: boolean;\r\n    $function?: boolean;\r\n    $variable?: boolean;\r\n    $important?: boolean;\r\n    $italic?: boolean;\r\n    $entity?: boolean;\r\n}\r\n\r\nconst Container = styled.span<Style>`\r\n  ${props => props.$comment && css`\r\n    color: slategray;\r\n  `}\r\n  ${props => props.$punctuation && css`\r\n    color: #999;\r\n  `}\r\n  ${props => props.$namespace && css`\r\n    opacity: .7;\r\n  `}\r\n  ${props => props.$property && css`\r\n    color: #905;\r\n  `}\r\n  ${props => props.$selector && css`\r\n    color: #690;\r\n  `}\r\n  ${props => props.$operator && css`\r\n    color: #9a6e3a;\r\n    background: hsla(0, 0%, 100%, .5);\r\n  `}\r\n  ${props => props.$keyword && css`\r\n    color: #07a;\r\n  `}\r\n  ${props => props.$function && css`\r\n    color: #DD4A68;\r\n  `}\r\n  ${props => props.$variable && css`\r\n    color: #e90;\r\n  `}\r\n  ${props => props.$important && css`\r\n    font-weight: bold;\r\n  `}\r\n  ${props => props.$italic && css`\r\n    font-style: italic;\r\n  `}\r\n  ${props => props.$entity && css`\r\n    cursor: help;\r\n  `}\r\n`;\r\n","import { GetComponentProps, useActions } from 'topwrite';\r\nimport { useEffect } from 'react';\r\nimport { HighlightPlugin } from '@/highlight-plugin';\r\n\r\nexport default function Activate({ children }: GetComponentProps<'activate'>) {\r\n    const { addPlugin, removePlugin } = useActions('editor');\r\n    useEffect(() => {\r\n        addPlugin(HighlightPlugin);\r\n        return () => {\r\n            removePlugin(HighlightPlugin);\r\n        };\r\n    }, []);\r\n    return children;\r\n}\r\n"],"names":["Prism","pattern","alias","leafDirective","languages","getLength","token","length","content","Array","isArray","reduce","l","t","HighlightPlugin","createPlatePlugin","renderLeaf","leaf","children","_jsx","Container","comment","prolog","doctype","cdata","punctuation","namespace","property","tag","boolean","number","constant","symbol","delete","selector","string","char","builtin","inserted","operator","entity","url","keyword","atrule","function","variable","regex","important","bold","italic","decorate","editor","isDocument","node","path","ranges","Element","lang","grammar","texts","from","Node","nodeText","map","text","join","tokens","textStart","textEnd","forEach","p","offset","processToken","marks","range","createRange","concat","start","end","push","type","i","language","mime","Text","anchor","focus","name","Math","max","min","mark","styled","props","$comment","css","$punctuation","$namespace","$property","$selector","$operator","$keyword","$function","$variable","$important","$italic","$entity","Activate","addPlugin","removePlugin","useActions","useEffect"],"sourceRoot":""}